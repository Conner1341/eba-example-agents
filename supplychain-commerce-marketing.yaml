version: 2
description: |-
  ### Example of questions
    - show me all shipments
    - show me affected shipments
    - what is in these shipments
    - show me affected mailings
    - pause these mailings
settings:
  - name: connectionString
    value: >-
      <enter connection string here>
concepts:
  - name: 'expo:PauseMailingsConf'
    ontology:
      subClassOf: ':Message'
  - name: ':Confirmation'
  - name: 'message:PauseCampaignsSuggestion'
    spelling: Would you like me to pause these campaigns?
  - name: ':Message'
  - name: ':Showable'
  - name: 'expo:Products'
    ontology:
      subClassOf: ':Showable'
  - name: ':Mailings'
  - name: 'expo:ShowContent'
  - name: ':Relation'
  - name: ':All'
  - name: ':ActionShow'
  - name: 'expo:Suppliers'
    ontology:
      isListOf: 'expo:Supplier'
      subClassOf: ':Showable'
  - name: 'message:AffectedShipments'
    spelling: shipment may be up to $1 late
  - name: 'expo:Affected'
  - name: 'message:CampaignsPaused'
    spelling: The following campaigns have been paused
  - name: 'expo:DistributionCenter'
    ontology:
      subClassOf: ':Showable'
  - name: 'expo:Shipments'
    spelling: shipments|*
    ontology:
      isListOf: 'expo:Shipment'
      subClassOf: ':Showable'
  - name: 'expo:Effect'
  - name: 'expo:Shipment'
    spelling: shipment
    ontology:
      subClassOf: ':Showable'
  - name: 'expo:DistributionCenters'
    ontology:
      subClassOf: ':Showable'
      isListOf: 'expo:DistributionCenter'
  - name: 'expo:Supplier'
    ontology:
      subClassOf: ':Showable'
  - name: ':ActionPause'
    ontology:
      subClassOf: ':Message'
  - name: 'expo:ShowAlerts'
  - name: 'weather:Alerts'
patterns:
  - '{pause|:ActionPause} these mailings'
  - 'show me all {suppliers|expo:Suppliers}'
  - '{what is in|expo:ShowContent} this shipments?'
  - '{what''s in|expo:ShowContent} this shipments?'
  - 'what is the {effect|expo:Effect}?'
  - 'show me all {distribution centers|expo:DistributionCenters}'
  - '{anything to worry about today|expo:ShowAlerts}?'
  - 'what {shipments|expo:Shipments} are {affected|expo:Affected}?'
actions:
  - name: 'expo:PauseMailings2'
    signature: ':ActionPause (context data :Mailings) -> data :ActionPause'
    kind: 'nodejs:8'
    code: |-
      const eba = require("eba")

      async function main(params) {
        let p = new eba.Params(params)
        let mailings = await p.get(":Mailings")

        return new eba.Result()
          .setMeta(":ActionPause", new eba.NLToken("message:CampaignsPaused"))
          .setData(":ActionPause", {
            "data": mailings,
            "name": ":PauseMailings"
          })
      }

      module.exports = {main}
  - name: 'expo:PauseMailings'
    signature: ':Confirmation (context data expo:PauseMailingsConf) -> data :ActionPause'
    kind: 'nodejs:8'
    code: |-
      const eba = require("eba")

      function main(params) {
        let p = new eba.Params(params)
        let info = p.get("expo:PauseMailingsConf")

        return new eba.Result()
          .setMeta(":ActionPause", new eba.NLToken("message:CampaignsPaused"))
          .setData(":ActionPause", {
            "data": info.mailings,
            "name": ":PauseMailings"
          })
      }

      module.exports = {main}
  - name: 'expo:GetAllDCs'
    signature: 'expo:DistributionCenters (optional :All) -> data expo:DistributionCenters'
    kind: 'nodejs:8'
    code: |-
      const eba = require("eba")
      const q = require("./query.js")

      async function main(params) {
        let result = await q.query(params.settings, "select id, name, address, city, state, zip from public.distribution_center")
        return new eba.Result().setData("expo:DistributionCenters", result)
      }

      module.exports = {main}
  - name: 'expo:GetAllShipments'
    signature: 'expo:Shipments (optional :All) -> data expo:Shipments'
    kind: 'nodejs:8'
    code: |-
      const eba = require("eba")
      const q = require("./query.js")

      async function main(params) {
        let items = await q.getShipments(params.settings)
        return new eba.Result().setData("expo:Shipments", {
          items: items,
          count: items.length
        })
      }

      module.exports = {main}
  - name: 'expo:GetAffectedMailings'
    signature: >-
      expo:Affected (data :Mailings, implicit data weather:Alerts) -> data
      :Mailings
    kind: 'nodejs:8'
    code: |-
      const eba    = require("eba")
      const _      = require("lodash")
      const moment = require("moment")
      const util   = require("./util.js")
      const query  = require("./query.js")

      async function getMailingIdsByProductIds(settings, productIds) {
        if (productIds.length) {
          let queryString = `select wca_mailing_id, conversion_rate from public.marketing where product_id in (${productIds.join(",")})`
          let rows = await query.query(settings, queryString)
          return _.map(rows, "wca_mailing_id")
        } else
          return []
      }

      async function main(params) {
        let p = new eba.Params(params)

        let shipments = await query.getShipments(params.settings)
        let mailings = await p.get(":Mailings")
        let alerts = await p.get("weather:Alerts")
        
        let affectedShipments = await util.getAffectedShipments(params.settings, alerts, shipments)
        let productIds = _.uniq(_.map(affectedShipments, "product_id"))
        let mailingIds = await getMailingIdsByProductIds(params.settings, productIds)
        let affectedMailings = _.filter(mailings, mailing => _.indexOf(mailingIds, mailing.mailingId) != -1)
        
        let weaterToken = p.getMeta("weather:Alerts")
        let mailingsToken = new eba.NLToken(":Mailings").addProperty("expo:AffectedBy", weaterToken)
        
        let result = new eba.Result()
          .setData(":Mailings", affectedMailings)
          .setMeta(":Mailings", mailingsToken)
          
        if (affectedMailings.length) {
          let token = new eba.NLToken(":ActionPause").addProperty("", new eba.NLToken(":Mailings").addProperty("reference:Direct"))
        
          result.set("@create", {
            "expo:Affected": {
              name: ":SuggestedContent",
              type: "data",
              data: token
            }
          })
          /*result.set("@create", {
            "expo:Affected": {
              name: "expo:PauseMailingsConf",
              type: "data",
              data: { mailings: affectedMailings },
              meta: new eba.NLToken("message:PauseCampaignsSuggestion")
            }
          })*/
        }
          
        return result
      }

      module.exports = {main}
  - name: 'expo:GetShipmentsProducts'
    signature: >-
      expo:Products (optional :Relation (data expo:Shipments)) -> data
      expo:Products
    kind: 'nodejs:8'
    code: |-
      const eba = require("eba")
      const _   = require("lodash")
      const q   = require("./query.js")

      async function main({settings, input}) {
        let shipments = input["expo:Shipments"].data.items
        let shipmentIds = _.map(shipments, "id").join(",")

        let queryString =
              `select p.id, p.name, p.description, p.image_url, s.inventory from public.product p
              join public.shipment s on s.product_id = p.id
              where s.id in (${shipmentIds})`

        let products = await q.query(settings, queryString)

        return new eba.Result().setData("expo:Products", {
          items: products,
          count: products.length
        })
      }

      module.exports = {main}
  - name: 'expo:GetAffectedShipments'
    signature: >-
      expo:Affected (data expo:Shipments, implicit data weather:Alerts) -> data
      expo:Shipments
    kind: 'nodejs:8'
    code: |-
      const eba    = require("eba")
      const _      = require("lodash")
      const moment = require("moment")
      const util   = require("./util.js")

      async function main({settings, input}) {
        let shipments = input["expo:Shipments"].data.items
        let alerts = input["weather:Alerts"].data
        let affectedShipments = await util.getAffectedShipments(settings, alerts, shipments)
        
        let shipment = _.maxBy(affectedShipments, "delay")
        let delay = moment.duration(shipment.delay, "second").humanize()
        
        return new eba.Result().setData("expo:Shipments", {
          items: affectedShipments,
          count: affectedShipments.length,
          message: `Based on past events, shipment may be up to ${delay} late`
        })
      }

      module.exports = {main}
  - name: 'expo:Suppliers'
    signature: 'expo:Suppliers (optional :All) -> data expo:Suppliers'
    kind: 'nodejs:8'
    code: |-
      const eba = require("eba")
      const q = require("./query.js")

      async function main(params) {
        let result = await q.query(params.settings, "select id, name, address, city, state, zip, product_id from public.supplier")
        return new eba.Result().setData("expo:Suppliers", result)
      }

      module.exports = {main}
rules:
  - name: ''
    signature: 'expo:Effect (a) -> :Mailings (expo:Affected)'
  - name: ''
    signature: 'expo:ShowContent (expo:Shipment) -> :ActionShow (expo:Products)'
  - name: ''
    signature: 'expo:ShowContent (expo:Shipments) -> :ActionShow (expo:Products)'
statics:
  - name: util.js
    mime: text/javascript
    text: |-
      const _   = require("lodash")
      const geo = require("./geo.js")
      const q   = require("./query.js")

      function getImpact(impacts, severity, distance) {
        let xs = _.filter(impacts, x => x.distance >= distance && x.severity >= severity)
        let x = _.minBy(xs, "ground_speed_factor")

        return x ? 1 / x.ground_speed_factor : 1
      }

      function enrichPoint(impacts, alerts, point) {
        let newAlerts = _(alerts)
              .map(wa => {
                let distance = geo.distance(point, wa)
                let impact = getImpact(impacts[wa.phenomena], wa.severity_cd, distance)
                return {
                  alert: wa,
                  impact: impact
                }
              })
              .filter(x => x.impact > 1)
              .groupBy("alert.phenomena")
              .values()
              .map(xs => _.maxBy(xs, "impact"))

        return {
          lat: point.lat,
          lon: point.lon,
          alerts: newAlerts.map("alert"),
          impact: newAlerts.map("impact").reduce((x, y) => x * y, 1)
        }
      }

      const sampleDistance = 10000

      function sampleRoute(impacts, alerts, points) {
        return _.zipWith(_.initial(points), _.tail(points), (p1, p2) => {
            let samples = Math.max(1, Math.round(geo.distance(p1, p2) / sampleDistance))
            let newPoints = Array(samples).fill().map((e, sample) => geo.interpolate(p1, p2, sample / samples)).map(ps => enrichPoint(impacts, alerts, ps))
            let impact = _.meanBy(newPoints, "impact")
            return {
              points: newPoints,
              delay: impact ? (impact - 1) * (p2.time - p1.time) : 0
            }
        })
      }

      async function getAffectedShipments(settings, alerts, shipments) {
        let rows = await q.query(settings, "select phenomena, severity, distance, ground_speed_factor from public.weather_impact order by phenomena")
        let impacts = _.groupBy(rows, "phenomena")
        console.log(impacts)
        
        return _.map(shipments, sh => {
          let xs = sampleRoute(impacts, alerts, sh.points)
          sh.route = _.map(xs, "points")
          sh.delay = _.sumBy(xs, "delay")
          return sh
        }).filter(sh => sh.delay > 0)
      }

      module.exports = {getAffectedShipments}
    notes: ''
    backend: true
  - name: geo.js
    mime: text/javascript
    text: |-
      // inspired by http://hackage.haskell.org/package/gps-1.2

      const radiusOfEarth = 6378700

      function toRadians(deg) {
        return deg * Math.PI / 180
      }

      function toDegrees(rad) {
        return rad * 180 / Math.PI
      }

      function getRadianPt({lat, lon}) {
        return {
          lat: toRadians(lat),
          lon: toRadians(lon)
        }
      }

      function distance(x, y) {
        let p1 = getRadianPt(x)
        let p2 = getRadianPt(y)
        let deltaLat = p2.lat - p1.lat
        let deltaLon = p2.lon - p1.lon
        
        let a = Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(p1.lat) * Math.cos(p2.lat) * Math.pow(Math.sin(deltaLon / 2), 2)
        let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

        return radiusOfEarth * c
      }

      function heading(x, y) {
        let p1 = getRadianPt(x)
        let p2 = getRadianPt(y)
        let deltaLon = p2.lon - p1.lon

        let a = Math.sin(deltaLon) * Math.cos(p2.lat)
        let b = Math.cos(p1.lat) * Math.sin(p2.lat) - Math.sin(p1.lat) * Math.cos(p2.lat) * Math.cos(deltaLon)

        return Math.atan2(a, b)
      }

      function addVector(d, h, p) {
        let p1 = getRadianPt(p)
        let lat2 = Math.asin(Math.sin(p1.lat) * Math.cos(d / radiusOfEarth) + Math.cos(p1.lat) * Math.sin(d / radiusOfEarth) * Math.cos(h))
        
        let a = Math.sin(h) * Math.sin(d / radiusOfEarth) * Math.cos(p1.lat)
        let b = Math.cos(d / radiusOfEarth) - Math.sin(p1.lat) * Math.sin(lat2)
        let lon2 = p1.lon + Math.atan2(a, b)

        return {
          lat: toDegrees(lat2),
          lon: toDegrees(lon2)
        }
      }

      function interpolate(c1, c2, w) {
        if (w < 0) return c1
        if (w > 1) return c2
        
        let h = heading(c1, c2)
        let d = distance(c1, c2)

        return addVector(d * w, h, c1)
      }

      module.exports = { heading, distance, interpolate }
    backend: true
  - name: query.js
    mime: text/javascript
    text: |-
      const pg = require("pg")
      const _ = require("lodash")

      async function query({connectionString}, queryString, values) {
        let client = new pg.Client({connectionString})
        client.connect()
        try {
          let {rows} = await client.query(queryString, values)
          return rows
        }
        finally {
          await client.end()
        }
      }

      async function getShipments(settings) {
        let queryString = [
              "select s.id, s.product_id, s.inventory, s.route_id, s.expected_date,",
              "p.lat, p.lon, rp.time, p.name, p.address, pr.name as product_name,",
              "sp.name as supplier_name, sp.address as supplier_address",
              "from public.shipment s",
              "join public.route_point rp on rp.route_id = s.route_id",
              "join public.point p on p.id = rp.point_id",
              "join public.product pr on pr.id = s.product_id",
              "join public.supplier sp on sp.id = s.supplier_id",
              "order by s.id, s.route_id, rp.time"].join("\n")

        let rows = await query(settings, queryString)
        return _.map(_.groupBy(rows, "id"), points => {
          let point = points[0]
          return _.merge({ points: points, route: null, delay: null }, point)
        })
      }

      module.exports = {query, getShipments}
    backend: true
